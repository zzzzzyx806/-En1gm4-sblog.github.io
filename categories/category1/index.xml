<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Category1 on My New Hugo Site</title>
    <link>https://zzzzzyx806.github.io/-En1gm4-sblog/categories/category1/</link>
    <description>Recent content in Category1 on My New Hugo Site</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 25 Oct 2024 13:45:26 +0800</lastBuildDate>
    <atom:link href="https://zzzzzyx806.github.io/-En1gm4-sblog/categories/category1/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Test</title>
      <link>https://zzzzzyx806.github.io/-En1gm4-sblog/post/test/</link>
      <pubDate>Fri, 25 Oct 2024 13:45:26 +0800</pubDate>
      <guid>https://zzzzzyx806.github.io/-En1gm4-sblog/post/test/</guid>
      <description>&lt;h2 id=&#34;introduce-rsa&#34;&gt;introduce RSA&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;介绍了 RSA 密码基本原理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;无法因式分解N时，枚举$Z^*_N$,时间复杂度为$O(N)$,没有讨论价值。&lt;/li&gt;&#xA;&lt;li&gt;要关注的是运行时间远小于N的算法,理想情况下这些算法的时间复杂度是 $O(n^c)$，其中 $n=log_⁡2N$，且常数 c 应该比较小（比如小于 5），这才是高效算法。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;RSA 函数&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一种陷门单向函数，即容易计算但很难在没有私钥d的情况下反转。&lt;/li&gt;&#xA;&lt;li&gt;用于数字签名：签名者用私钥$⟨N,d⟩$进行签名，任何人都可用公钥验证签名，具体签名S为：$$S = M^d \mod N$$&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;分解因式 N 以解密&#xA;&lt;ul&gt;&#xA;&lt;li&gt;目前分解大整数的最佳算法是 General Number Field Sieve ，时间复杂度为:$$\exp\left( (c + o(1))n^{1/3} (\log n)^{2/3} \right)$$&lt;/li&gt;&#xA;&lt;li&gt;如果 p−1 是小质数的乘积，则 N 容易被分解&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;open problem 1&lt;/strong&gt; :是否必须进行因数分解才能破解 RSA ?给定 N 和加密指数 e ，我们能否在不分解 N 的情况下高效地计算出明文的 e 次根模 N？&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Fact 1&lt;/strong&gt;：知道私钥 d 和分解 N 等效，如果知道私钥 d，可以高效地对模数 N=pq 进行因数分解；反之，给定模数 N 的因数分解，也可以高效地恢复私钥 d。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;证明:设 $k=de−1$, k 是 $\phi(N$) 的倍数。&#xA;ϕ(N) 是偶数，因此 k 可以表示为 $k = 2^t r$，其中  r 是一个奇数，且 $t \geq 1$。&#xA;对于任意 $g \in Z^*_N$,$g^k≡1\mod N$,&#xA;x$≡1\ mod\ p$, $x \equiv -1 \mod q$,计算 $\text{gcd}(x - 1, N)$,d得到p或q&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;elementary-attacks&#34;&gt;elementary attacks&lt;/h1&gt;&#xA;&lt;h3 id=&#34;common-modulus使用相同的n&#34;&gt;Common Modulus（使用相同的N）&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用相同的模数 N=p*q 为多个用户加密，为每个用户提供不同的公钥和私钥&lt;/li&gt;&#xA;&lt;li&gt;表面上看，一个用户无法知道其他人的d，所以是安全的&lt;/li&gt;&#xA;&lt;li&gt;事实上一个用户可以用他的e和d对N进行因式分解，从而在别人的e中知道别人的d&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;blinding盲签名&#34;&gt;Blinding(盲签名)&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;定义：即能够在不知道原始消息的情况下完成签名&lt;/li&gt;&#xA;&lt;li&gt;实现过程：&#xA;&lt;ol&gt;&#xA;&lt;li&gt;选择一个随机数:$r \in \mathbb{Z}^*_N$&lt;/li&gt;&#xA;&lt;li&gt;构造盲消息$M_0$:$M_0 = r^e M \mod N$&lt;/li&gt;&#xA;&lt;li&gt;签名者在不知道原始消息 M 的情况下对$M_1$进行签名：$S_0 = M_0^d \mod N$&lt;/li&gt;&#xA;&lt;li&gt;提取有效签名：$S =  S_0/r \mod N$&#xA;正确性：$S^e = ( S_0)^e/r^e\equiv  (M_0)^d/r^e\equiv  (r^e M)^d/r^e\equiv M \mod N$&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;low-private-exponent-attacksd小&#34;&gt;low private exponent attacks（d小）&lt;/h1&gt;&#xA;&lt;p&gt;为了减少解密时间，可能使用较小的 d ，但是 d 很小容易被使用 Wiener 定理轻松破解&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
