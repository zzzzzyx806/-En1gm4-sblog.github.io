<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Category1 on My New Hugo Site</title>
    <link>http://localhost:1313/-En1gm4-sblog.github.io/categories/category1/</link>
    <description>Recent content in Category1 on My New Hugo Site</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 31 Oct 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/-En1gm4-sblog.github.io/categories/category1/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>New Post Title</title>
      <link>http://localhost:1313/-En1gm4-sblog.github.io/post/diffie-hellman%E5%92%8Celgamal/</link>
      <pubDate>Thu, 31 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/-En1gm4-sblog.github.io/post/diffie-hellman%E5%92%8Celgamal/</guid>
      <description>&lt;h1 id=&#34;diffie-hellman&#34;&gt;Diffie-Hellman&lt;/h1&gt;&#xA;&lt;p&gt;Diffie-Hellman密钥交换是一种允许两方在不安全的通道上安全地共享密钥的方法。其基本思想是利用离散对数问题的难解性，确保即使攻击者能够监听双方的通信，也无法轻易计算出共享的密钥。&lt;/p&gt;&#xA;&lt;h3 id=&#34;具体步骤&#34;&gt;具体步骤&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;初始化&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;两方（通常称为Alice和Bob）首先选择一个大型素数 p 和一个生成元 g（一个小于 p 的整数，且 g 在模 p 意义下是一个原根).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;私钥选择&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Alice 随机选择一个私钥 a，Bob 随机选择一个私钥 b。这两个私钥必须保密。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;计算公钥&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Alice 计算她的公钥 A： $A = g^a \mod p$&lt;/li&gt;&#xA;&lt;li&gt;Bob 计算他的公钥 B： $B = g^b \mod p$&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;交换公钥&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Alice 将公钥 A 发送给 Bob，Bob 将公钥 B 发送给 Alice。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;计算共享密钥&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Alice 使用 Bob 的公钥 B 计算共享密钥K： $K = B^a \mod p$&lt;/li&gt;&#xA;&lt;li&gt;Bob 使用 Alice 的公钥 A 计算共享密钥K： $K = A^b \mod p$&lt;/li&gt;&#xA;&lt;li&gt;由于数学性质，两个计算出的共享密钥 K 是相同的：$K = (g^b)^a \mod p = (g^a)^b \mod p$&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;安全性分析&#34;&gt;安全性分析&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;离散对数问题&lt;/strong&gt;：尽管公钥 A 和 B 是公开的，攻击者如果试图计算共享密钥 K，需要解决离散对数问题，即从 A 和 g 计算出私钥 a 或从 B 和 g 计算出私钥 b。这是目前已知的非常困难的问题。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Twenty Years of  Attacks on the RSA  Cryptosystem</title>
      <link>http://localhost:1313/-En1gm4-sblog.github.io/post/twenty-years/</link>
      <pubDate>Fri, 25 Oct 2024 13:45:26 +0800</pubDate>
      <guid>http://localhost:1313/-En1gm4-sblog.github.io/post/twenty-years/</guid>
      <description>&lt;h2 id=&#34;introduce-rsa&#34;&gt;introduce RSA&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;介绍了 RSA 密码基本原理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;无法因式分解N时，枚举$Z^*_N$,时间复杂度为$O(N)$,没有讨论价值。&lt;/li&gt;&#xA;&lt;li&gt;要关注的是运行时间远小于N的算法,理想情况下这些算法的时间复杂度是 $O(n^c)$，其中 $n=log_⁡2N$，且常数 c 应该比较小（比如小于 5），这才是高效算法。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;RSA 函数&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一种陷门单向函数，即容易计算但很难在没有私钥d的情况下反转。&lt;/li&gt;&#xA;&lt;li&gt;用于数字签名：签名者用私钥$⟨N,d⟩$进行签名，任何人都可用公钥验证签名，具体签名S为：$$S = M^d \mod N$$&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;分解因式 N 以解密&#xA;&lt;ul&gt;&#xA;&lt;li&gt;目前分解大整数的最佳算法是 General Number Field Sieve ，时间复杂度为:$$\exp\left( (c + o(1))n^{1/3} (\log n)^{2/3} \right)$$&lt;/li&gt;&#xA;&lt;li&gt;如果 p−1 是小质数的乘积，则 N 容易被分解&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;open problem 1&lt;/strong&gt; :是否必须进行因数分解才能破解 RSA ?给定 N 和加密指数 e ，我们能否在不分解 N 的情况下高效地计算出明文的 e 次根模 N？&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Fact 1&lt;/strong&gt;：知道私钥 d 和分解 N 等效，如果知道私钥 d，可以高效地对模数 N=pq 进行因数分解；反之，给定模数 N 的因数分解，也可以高效地恢复私钥 d。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;证明:设 $k=de−1$, k 是 $\phi(N$) 的倍数。&#xA;ϕ(N) 是偶数，因此 k 可以表示为 $k = 2^t r$，其中  r 是一个奇数，且 $t \geq 1$。&#xA;对于任意 $g \in Z^*_N$,$g^k≡1\mod N$,&#xA;x$≡1\ mod\ p$, $x \equiv -1 \mod q$,计算 $\text{gcd}(x - 1, N)$,d得到p或q&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;elementary-attacks&#34;&gt;elementary attacks&lt;/h1&gt;&#xA;&lt;h3 id=&#34;common-modulus使用相同的n&#34;&gt;Common Modulus（使用相同的N）&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用相同的模数 N=p*q 为多个用户加密，为每个用户提供不同的公钥和私钥&lt;/li&gt;&#xA;&lt;li&gt;表面上看，一个用户无法知道其他人的d，所以是安全的&lt;/li&gt;&#xA;&lt;li&gt;事实上一个用户可以用他的e和d对N进行因式分解，从而在别人的e中知道别人的d&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;blinding盲签名&#34;&gt;Blinding(盲签名)&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;定义：即能够在不知道原始消息的情况下完成签名&lt;/li&gt;&#xA;&lt;li&gt;实现过程：&#xA;&lt;ol&gt;&#xA;&lt;li&gt;选择一个随机数:$r \in \mathbb{Z}^*_N$&lt;/li&gt;&#xA;&lt;li&gt;构造盲消息$M_0$:$M_0 = r^e M \mod N$&lt;/li&gt;&#xA;&lt;li&gt;签名者在不知道原始消息 M 的情况下对$M_1$进行签名：$S_0 = M_0^d \mod N$&lt;/li&gt;&#xA;&lt;li&gt;提取有效签名：$S =  S_0/r \mod N$&#xA;正确性：$S^e = ( S_0)^e/r^e\equiv  (M_0)^d/r^e\equiv  (r^e M)^d/r^e\equiv M \mod N$&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;low-private-exponent-attacksd小&#34;&gt;low private exponent attacks（d小）&lt;/h1&gt;&#xA;&lt;p&gt;为了减少解密时间，可能使用较小的 d ，但是 d 很小容易被使用 Wiener 定理轻松破解&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
